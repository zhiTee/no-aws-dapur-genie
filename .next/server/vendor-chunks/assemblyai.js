"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/assemblyai";
exports.ids = ["vendor-chunks/assemblyai"];
exports.modules = {

/***/ "(rsc)/./node_modules/assemblyai/dist/node.mjs":
/*!***********************************************!*\
  !*** ./node_modules/assemblyai/dist/node.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssemblyAI: () => (/* binding */ AssemblyAI),\n/* harmony export */   FileService: () => (/* binding */ FileService),\n/* harmony export */   LemurService: () => (/* binding */ LemurService),\n/* harmony export */   RealtimeService: () => (/* binding */ RealtimeService),\n/* harmony export */   RealtimeServiceFactory: () => (/* binding */ RealtimeServiceFactory),\n/* harmony export */   RealtimeTranscriber: () => (/* binding */ RealtimeTranscriber),\n/* harmony export */   RealtimeTranscriberFactory: () => (/* binding */ RealtimeTranscriberFactory),\n/* harmony export */   StreamingTranscriber: () => (/* binding */ StreamingTranscriber),\n/* harmony export */   TranscriptService: () => (/* binding */ TranscriptService)\n/* harmony export */ });\n/* harmony import */ var stream_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream/web */ \"stream/web\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ \"stream\");\n\n\n\n\n\nconst DEFAULT_FETCH_INIT = {\n    cache: \"no-store\",\n};\n\nconst buildUserAgent = (userAgent) => defaultUserAgentString +\n    (userAgent === false\n        ? \"\"\n        : \" AssemblyAI/1.0 (\" +\n            Object.entries({ ...defaultUserAgent, ...userAgent })\n                .map(([key, item]) => item ? `${key}=${item.name}/${item.version}` : \"\")\n                .join(\" \") +\n            \")\");\nlet defaultUserAgentString = \"\";\nif (typeof navigator !== \"undefined\" && navigator.userAgent) {\n    defaultUserAgentString += navigator.userAgent;\n}\nconst defaultUserAgent = {\n    sdk: { name: \"JavaScript\", version: \"4.16.1\" },\n};\nif (typeof process !== \"undefined\") {\n    if (process.versions.node && defaultUserAgentString.indexOf(\"Node\") === -1) {\n        defaultUserAgent.runtime_env = {\n            name: \"Node\",\n            version: process.versions.node,\n        };\n    }\n    if (process.versions.bun && defaultUserAgentString.indexOf(\"Bun\") === -1) {\n        defaultUserAgent.runtime_env = {\n            name: \"Bun\",\n            version: process.versions.bun,\n        };\n    }\n}\nif (typeof Deno !== \"undefined\") {\n    if (process.versions.bun && defaultUserAgentString.indexOf(\"Deno\") === -1) {\n        defaultUserAgent.runtime_env = { name: \"Deno\", version: Deno.version.deno };\n    }\n}\n\n/**\n * Base class for services that communicate with the API.\n */\nclass BaseService {\n    /**\n     * Create a new service.\n     * @param params - The parameters to use for the service.\n     */\n    constructor(params) {\n        this.params = params;\n        if (params.userAgent === false) {\n            this.userAgent = undefined;\n        }\n        else {\n            this.userAgent = buildUserAgent(params.userAgent || {});\n        }\n    }\n    async fetch(input, init) {\n        init = { ...DEFAULT_FETCH_INIT, ...init };\n        let headers = {\n            Authorization: this.params.apiKey,\n            \"Content-Type\": \"application/json\",\n        };\n        if (DEFAULT_FETCH_INIT?.headers)\n            headers = { ...headers, ...DEFAULT_FETCH_INIT.headers };\n        if (init?.headers)\n            headers = { ...headers, ...init.headers };\n        if (this.userAgent) {\n            headers[\"User-Agent\"] = this.userAgent;\n        }\n        init.headers = headers;\n        if (!input.startsWith(\"http\"))\n            input = this.params.baseUrl + input;\n        const response = await fetch(input, init);\n        if (response.status >= 400) {\n            let json;\n            const text = await response.text();\n            if (text) {\n                try {\n                    json = JSON.parse(text);\n                }\n                catch {\n                    /* empty */\n                }\n                if (json?.error)\n                    throw new Error(json.error);\n                throw new Error(text);\n            }\n            throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async fetchJson(input, init) {\n        const response = await this.fetch(input, init);\n        return response.json();\n    }\n}\n\nclass LemurService extends BaseService {\n    summary(params) {\n        return this.fetchJson(\"/lemur/v3/generate/summary\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    questionAnswer(params) {\n        return this.fetchJson(\"/lemur/v3/generate/question-answer\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    actionItems(params) {\n        return this.fetchJson(\"/lemur/v3/generate/action-items\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    task(params) {\n        return this.fetchJson(\"/lemur/v3/generate/task\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    getResponse(id) {\n        return this.fetchJson(`/lemur/v3/${id}`);\n    }\n    /**\n     * Delete the data for a previously submitted LeMUR request.\n     * @param id - ID of the LeMUR request\n     */\n    purgeRequestData(id) {\n        return this.fetchJson(`/lemur/v3/${id}`, {\n            method: \"DELETE\",\n        });\n    }\n}\n\nconst factory = (url, params) => new ws__WEBPACK_IMPORTED_MODULE_1__[\"default\"](url, params);\n\nconst RealtimeErrorType = {\n    BadSampleRate: 4000,\n    AuthFailed: 4001,\n    /**\n     * @deprecated Use InsufficientFunds or FreeTierUser instead\n     */\n    InsufficientFundsOrFreeAccount: 4002,\n    InsufficientFunds: 4002,\n    FreeTierUser: 4003,\n    NonexistentSessionId: 4004,\n    SessionExpired: 4008,\n    ClosedSession: 4010,\n    RateLimited: 4029,\n    UniqueSessionViolation: 4030,\n    SessionTimeout: 4031,\n    AudioTooShort: 4032,\n    AudioTooLong: 4033,\n    AudioTooSmallToTranscode: 4034,\n    /**\n     * @deprecated Don't use\n     */\n    BadJson: 4100,\n    BadSchema: 4101,\n    TooManyStreams: 4102,\n    Reconnected: 4103,\n    /**\n     * @deprecated Don't use\n     */\n    ReconnectAttemptsExhausted: 1013,\n    WordBoostParameterParsingFailed: 4104,\n};\nconst RealtimeErrorMessages = {\n    [RealtimeErrorType.BadSampleRate]: \"Sample rate must be a positive integer\",\n    [RealtimeErrorType.AuthFailed]: \"Not Authorized\",\n    [RealtimeErrorType.InsufficientFunds]: \"Insufficient funds\",\n    [RealtimeErrorType.FreeTierUser]: \"This feature is paid-only and requires you to add a credit card. Please visit https://app.assemblyai.com/ to add a credit card to your account.\",\n    [RealtimeErrorType.NonexistentSessionId]: \"Session ID does not exist\",\n    [RealtimeErrorType.SessionExpired]: \"Session has expired\",\n    [RealtimeErrorType.ClosedSession]: \"Session is closed\",\n    [RealtimeErrorType.RateLimited]: \"Rate limited\",\n    [RealtimeErrorType.UniqueSessionViolation]: \"Unique session violation\",\n    [RealtimeErrorType.SessionTimeout]: \"Session Timeout\",\n    [RealtimeErrorType.AudioTooShort]: \"Audio too short\",\n    [RealtimeErrorType.AudioTooLong]: \"Audio too long\",\n    [RealtimeErrorType.AudioTooSmallToTranscode]: \"Audio too small to transcode\",\n    [RealtimeErrorType.BadJson]: \"Bad JSON\",\n    [RealtimeErrorType.BadSchema]: \"Bad schema\",\n    [RealtimeErrorType.TooManyStreams]: \"Too many streams\",\n    [RealtimeErrorType.Reconnected]: \"This session has been reconnected. This WebSocket is no longer valid.\",\n    [RealtimeErrorType.ReconnectAttemptsExhausted]: \"Reconnect attempts exhausted\",\n    [RealtimeErrorType.WordBoostParameterParsingFailed]: \"Could not parse word boost parameter\",\n};\nclass RealtimeError extends Error {\n}\n\nconst StreamingErrorType = {\n    BadSampleRate: 4000,\n    AuthFailed: 4001,\n    InsufficientFunds: 4002,\n    FreeTierUser: 4003,\n    NonexistentSessionId: 4004,\n    SessionExpired: 4008,\n    ClosedSession: 4010,\n    RateLimited: 4029,\n    UniqueSessionViolation: 4030,\n    SessionTimeout: 4031,\n    AudioTooShort: 4032,\n    AudioTooLong: 4033,\n    AudioTooSmallToTranscode: 4034,\n    BadSchema: 4101,\n    TooManyStreams: 4102,\n    Reconnected: 4103,\n};\nconst StreamingErrorMessages = {\n    [StreamingErrorType.BadSampleRate]: \"Sample rate must be a positive integer\",\n    [StreamingErrorType.AuthFailed]: \"Not Authorized\",\n    [StreamingErrorType.InsufficientFunds]: \"Insufficient funds\",\n    [StreamingErrorType.FreeTierUser]: \"This feature is paid-only and requires you to add a credit card. Please visit https://app.assemblyai.com/ to add a credit card to your account.\",\n    [StreamingErrorType.NonexistentSessionId]: \"Session ID does not exist\",\n    [StreamingErrorType.SessionExpired]: \"Session has expired\",\n    [StreamingErrorType.ClosedSession]: \"Session is closed\",\n    [StreamingErrorType.RateLimited]: \"Rate limited\",\n    [StreamingErrorType.UniqueSessionViolation]: \"Unique session violation\",\n    [StreamingErrorType.SessionTimeout]: \"Session Timeout\",\n    [StreamingErrorType.AudioTooShort]: \"Audio too short\",\n    [StreamingErrorType.AudioTooLong]: \"Audio too long\",\n    [StreamingErrorType.AudioTooSmallToTranscode]: \"Audio too small to transcode\",\n    [StreamingErrorType.BadSchema]: \"Bad schema\",\n    [StreamingErrorType.TooManyStreams]: \"Too many streams\",\n    [StreamingErrorType.Reconnected]: \"This session has been reconnected. This WebSocket is no longer valid.\",\n};\nclass StreamingError extends Error {\n}\n\nconst defaultRealtimeUrl = \"wss://api.assemblyai.com/v2/realtime/ws\";\nconst forceEndOfUtteranceMessage = `{\"force_end_utterance\":true}`;\nconst terminateSessionMessage$1 = `{\"terminate_session\":true}`;\n/**\n * RealtimeTranscriber connects to the Streaming Speech-to-Text API and lets you transcribe audio in real-time.\n */\nclass RealtimeTranscriber {\n    /**\n     * Create a new RealtimeTranscriber.\n     * @param params - Parameters to configure the RealtimeTranscriber\n     */\n    constructor(params) {\n        this.listeners = {};\n        this.realtimeUrl = params.realtimeUrl ?? defaultRealtimeUrl;\n        this.sampleRate = params.sampleRate ?? 16_000;\n        this.wordBoost = params.wordBoost;\n        this.encoding = params.encoding;\n        this.endUtteranceSilenceThreshold = params.endUtteranceSilenceThreshold;\n        this.disablePartialTranscripts = params.disablePartialTranscripts;\n        if (\"token\" in params && params.token)\n            this.token = params.token;\n        if (\"apiKey\" in params && params.apiKey)\n            this.apiKey = params.apiKey;\n        if (!(this.token || this.apiKey)) {\n            throw new Error(\"API key or temporary token is required.\");\n        }\n    }\n    connectionUrl() {\n        const url = new URL(this.realtimeUrl);\n        if (url.protocol !== \"wss:\") {\n            throw new Error(\"Invalid protocol, must be wss\");\n        }\n        const searchParams = new URLSearchParams();\n        if (this.token) {\n            searchParams.set(\"token\", this.token);\n        }\n        searchParams.set(\"sample_rate\", this.sampleRate.toString());\n        if (this.wordBoost && this.wordBoost.length > 0) {\n            searchParams.set(\"word_boost\", JSON.stringify(this.wordBoost));\n        }\n        if (this.encoding) {\n            searchParams.set(\"encoding\", this.encoding);\n        }\n        searchParams.set(\"enable_extra_session_information\", \"true\");\n        if (this.disablePartialTranscripts) {\n            searchParams.set(\"disable_partial_transcripts\", this.disablePartialTranscripts.toString());\n        }\n        url.search = searchParams.toString();\n        return url;\n    }\n    /**\n     * Add a listener for an event.\n     * @param event - The event to listen for.\n     * @param listener - The function to call when the event is emitted.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    on(event, listener) {\n        this.listeners[event] = listener;\n    }\n    /**\n     * Connect to the server and begin a new session.\n     * @returns A promise that resolves when the connection is established and the session begins.\n     */\n    connect() {\n        return new Promise((resolve) => {\n            if (this.socket) {\n                throw new Error(\"Already connected\");\n            }\n            const url = this.connectionUrl();\n            if (this.token) {\n                this.socket = factory(url.toString());\n            }\n            else {\n                this.socket = factory(url.toString(), {\n                    headers: { Authorization: this.apiKey },\n                });\n            }\n            this.socket.binaryType = \"arraybuffer\";\n            this.socket.onopen = () => {\n                if (this.endUtteranceSilenceThreshold === undefined ||\n                    this.endUtteranceSilenceThreshold === null) {\n                    return;\n                }\n                this.configureEndUtteranceSilenceThreshold(this.endUtteranceSilenceThreshold);\n            };\n            this.socket.onclose = ({ code, reason }) => {\n                if (!reason) {\n                    if (code in RealtimeErrorMessages) {\n                        reason = RealtimeErrorMessages[code];\n                    }\n                }\n                this.listeners.close?.(code, reason);\n            };\n            this.socket.onerror = (event) => {\n                if (event.error)\n                    this.listeners.error?.(event.error);\n                else\n                    this.listeners.error?.(new Error(event.message));\n            };\n            this.socket.onmessage = ({ data }) => {\n                const message = JSON.parse(data.toString());\n                if (\"error\" in message) {\n                    this.listeners.error?.(new RealtimeError(message.error));\n                    return;\n                }\n                switch (message.message_type) {\n                    case \"SessionBegins\": {\n                        const openObject = {\n                            sessionId: message.session_id,\n                            expiresAt: new Date(message.expires_at),\n                        };\n                        resolve(openObject);\n                        this.listeners.open?.(openObject);\n                        break;\n                    }\n                    case \"PartialTranscript\": {\n                        // message.created is actually a string when coming from the socket\n                        message.created = new Date(message.created);\n                        this.listeners.transcript?.(message);\n                        this.listeners[\"transcript.partial\"]?.(message);\n                        break;\n                    }\n                    case \"FinalTranscript\": {\n                        // message.created is actually a string when coming from the socket\n                        message.created = new Date(message.created);\n                        this.listeners.transcript?.(message);\n                        this.listeners[\"transcript.final\"]?.(message);\n                        break;\n                    }\n                    case \"SessionInformation\": {\n                        this.listeners.session_information?.(message);\n                        break;\n                    }\n                    case \"SessionTerminated\": {\n                        this.sessionTerminatedResolve?.();\n                        break;\n                    }\n                }\n            };\n        });\n    }\n    /**\n     * Send audio data to the server.\n     * @param audio - The audio data to send to the server.\n     */\n    sendAudio(audio) {\n        this.send(audio);\n    }\n    /**\n     * Create a writable stream that can be used to send audio data to the server.\n     * @returns A writable stream that can be used to send audio data to the server.\n     */\n    stream() {\n        return new stream_web__WEBPACK_IMPORTED_MODULE_0__.WritableStream({\n            write: (chunk) => {\n                this.sendAudio(chunk);\n            },\n        });\n    }\n    /**\n     * Manually end an utterance\n     */\n    forceEndUtterance() {\n        this.send(forceEndOfUtteranceMessage);\n    }\n    /**\n     * Configure the threshold for how long to wait before ending an utterance. Default is 700ms.\n     * @param threshold - The duration of the end utterance silence threshold in milliseconds.\n     * This value must be an integer between 0 and 20_000.\n     */\n    configureEndUtteranceSilenceThreshold(threshold) {\n        this.send(`{\"end_utterance_silence_threshold\":${threshold}}`);\n    }\n    send(data) {\n        if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n            throw new Error(\"Socket is not open for communication\");\n        }\n        this.socket.send(data);\n    }\n    /**\n     * Close the connection to the server.\n     * @param waitForSessionTermination - If true, the method will wait for the session to be terminated before closing the connection.\n     * While waiting for the session to be terminated, you will receive the final transcript and session information.\n     */\n    async close(waitForSessionTermination = true) {\n        if (this.socket) {\n            if (this.socket.readyState === this.socket.OPEN) {\n                if (waitForSessionTermination) {\n                    const sessionTerminatedPromise = new Promise((resolve) => {\n                        this.sessionTerminatedResolve = resolve;\n                    });\n                    this.socket.send(terminateSessionMessage$1);\n                    await sessionTerminatedPromise;\n                }\n                else {\n                    this.socket.send(terminateSessionMessage$1);\n                }\n            }\n            if (this.socket?.removeAllListeners)\n                this.socket.removeAllListeners();\n            this.socket.close();\n        }\n        this.listeners = {};\n        this.socket = undefined;\n    }\n}\n/**\n * @deprecated Use RealtimeTranscriber instead\n */\nclass RealtimeService extends RealtimeTranscriber {\n}\n\nclass RealtimeTranscriberFactory extends BaseService {\n    constructor(params) {\n        super(params);\n        this.rtFactoryParams = params;\n    }\n    /**\n     * @deprecated Use transcriber(...) instead\n     */\n    createService(params) {\n        return this.transcriber(params);\n    }\n    transcriber(params) {\n        const serviceParams = { ...params };\n        if (!serviceParams.token && !serviceParams.apiKey) {\n            serviceParams.apiKey = this.rtFactoryParams.apiKey;\n        }\n        return new RealtimeTranscriber(serviceParams);\n    }\n    async createTemporaryToken(params) {\n        const data = await this.fetchJson(\"/v2/realtime/token\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n        return data.token;\n    }\n}\n/**\n * @deprecated Use RealtimeTranscriberFactory instead\n */\nclass RealtimeServiceFactory extends RealtimeTranscriberFactory {\n}\n\nfunction getPath(path) {\n    if (path.startsWith(\"http\"))\n        return null;\n    if (path.startsWith(\"https\"))\n        return null;\n    if (path.startsWith(\"data:\"))\n        return null;\n    if (path.startsWith(\"file://\"))\n        return path.substring(7);\n    if (path.startsWith(\"file:\"))\n        return path.substring(5);\n    return path;\n}\n\nclass TranscriptService extends BaseService {\n    constructor(params, files) {\n        super(params);\n        this.files = files;\n    }\n    /**\n     * Transcribe an audio file. This will create a transcript and wait until the transcript status is \"completed\" or \"error\".\n     * @param params - The parameters to transcribe an audio file.\n     * @param options - The options to transcribe an audio file.\n     * @returns A promise that resolves to the transcript. The transcript status is \"completed\" or \"error\".\n     */\n    async transcribe(params, options) {\n        const transcript = await this.submit(params);\n        return await this.waitUntilReady(transcript.id, options);\n    }\n    /**\n     * Submits a transcription job for an audio file. This will not wait until the transcript status is \"completed\" or \"error\".\n     * @param params - The parameters to start the transcription of an audio file.\n     * @returns A promise that resolves to the queued transcript.\n     */\n    async submit(params) {\n        let audioUrl;\n        let transcriptParams = undefined;\n        if (\"audio\" in params) {\n            const { audio, ...audioTranscriptParams } = params;\n            if (typeof audio === \"string\") {\n                const path = getPath(audio);\n                if (path !== null) {\n                    // audio is local path, upload local file\n                    audioUrl = await this.files.upload(path);\n                }\n                else {\n                    if (audio.startsWith(\"data:\")) {\n                        audioUrl = await this.files.upload(audio);\n                    }\n                    else {\n                        // audio is not a local path, and not a data-URI, assume it's a normal URL\n                        audioUrl = audio;\n                    }\n                }\n            }\n            else {\n                // audio is of uploadable type\n                audioUrl = await this.files.upload(audio);\n            }\n            transcriptParams = { ...audioTranscriptParams, audio_url: audioUrl };\n        }\n        else {\n            transcriptParams = params;\n        }\n        const data = await this.fetchJson(\"/v2/transcript\", {\n            method: \"POST\",\n            body: JSON.stringify(transcriptParams),\n        });\n        return data;\n    }\n    /**\n     * Create a transcript.\n     * @param params - The parameters to create a transcript.\n     * @param options - The options used for creating the new transcript.\n     * @returns A promise that resolves to the transcript.\n     * @deprecated Use `transcribe` instead to transcribe a audio file that includes polling, or `submit` to transcribe a audio file without polling.\n     */\n    async create(params, options) {\n        const path = getPath(params.audio_url);\n        if (path !== null) {\n            const uploadUrl = await this.files.upload(path);\n            params.audio_url = uploadUrl;\n        }\n        const data = await this.fetchJson(\"/v2/transcript\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n        if (options?.poll ?? true) {\n            return await this.waitUntilReady(data.id, options);\n        }\n        return data;\n    }\n    /**\n     * Wait until the transcript ready, either the status is \"completed\" or \"error\".\n     * @param transcriptId - The ID of the transcript.\n     * @param options - The options to wait until the transcript is ready.\n     * @returns A promise that resolves to the transcript. The transcript status is \"completed\" or \"error\".\n     */\n    async waitUntilReady(transcriptId, options) {\n        const pollingInterval = options?.pollingInterval ?? 3_000;\n        const pollingTimeout = options?.pollingTimeout ?? -1;\n        const startTime = Date.now();\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const transcript = await this.get(transcriptId);\n            if (transcript.status === \"completed\" || transcript.status === \"error\") {\n                return transcript;\n            }\n            else if (pollingTimeout > 0 &&\n                Date.now() - startTime > pollingTimeout) {\n                throw new Error(\"Polling timeout\");\n            }\n            else {\n                await new Promise((resolve) => setTimeout(resolve, pollingInterval));\n            }\n        }\n    }\n    /**\n     * Retrieve a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the transcript.\n     */\n    get(id) {\n        return this.fetchJson(`/v2/transcript/${id}`);\n    }\n    /**\n     * Retrieves a page of transcript listings.\n     * @param params - The parameters to filter the transcript list by, or the URL to retrieve the transcript list from.\n     */\n    async list(params) {\n        let url = \"/v2/transcript\";\n        if (typeof params === \"string\") {\n            url = params;\n        }\n        else if (params) {\n            url = `${url}?${new URLSearchParams(Object.keys(params).map((key) => [\n                key,\n                params[key]?.toString() || \"\",\n            ]))}`;\n        }\n        const data = await this.fetchJson(url);\n        for (const transcriptListItem of data.transcripts) {\n            transcriptListItem.created = new Date(transcriptListItem.created);\n            if (transcriptListItem.completed) {\n                transcriptListItem.completed = new Date(transcriptListItem.completed);\n            }\n        }\n        return data;\n    }\n    /**\n     * Delete a transcript\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the transcript.\n     */\n    delete(id) {\n        return this.fetchJson(`/v2/transcript/${id}`, { method: \"DELETE\" });\n    }\n    /**\n     * Search through the transcript for a specific set of keywords.\n     * You can search for individual words, numbers, or phrases containing up to five words or numbers.\n     * @param id - The identifier of the transcript.\n     * @param words - Keywords to search for.\n     * @returns A promise that resolves to the sentences.\n     */\n    wordSearch(id, words) {\n        const params = new URLSearchParams({ words: words.join(\",\") });\n        return this.fetchJson(`/v2/transcript/${id}/word-search?${params.toString()}`);\n    }\n    /**\n     * Retrieve all sentences of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the sentences.\n     */\n    sentences(id) {\n        return this.fetchJson(`/v2/transcript/${id}/sentences`);\n    }\n    /**\n     * Retrieve all paragraphs of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the paragraphs.\n     */\n    paragraphs(id) {\n        return this.fetchJson(`/v2/transcript/${id}/paragraphs`);\n    }\n    /**\n     * Retrieve subtitles of a transcript.\n     * @param id - The identifier of the transcript.\n     * @param format - The format of the subtitles.\n     * @param chars_per_caption - The maximum number of characters per caption.\n     * @returns A promise that resolves to the subtitles text.\n     */\n    async subtitles(id, format = \"srt\", chars_per_caption) {\n        let url = `/v2/transcript/${id}/${format}`;\n        if (chars_per_caption) {\n            const params = new URLSearchParams();\n            params.set(\"chars_per_caption\", chars_per_caption.toString());\n            url += `?${params.toString()}`;\n        }\n        const response = await this.fetch(url);\n        return await response.text();\n    }\n    /**\n     * Retrieve the redacted audio URL of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the details of the redacted audio.\n     * @deprecated Use `redactedAudio` instead.\n     */\n    redactions(id) {\n        return this.redactedAudio(id);\n    }\n    /**\n     * Retrieve the redacted audio URL of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the details of the redacted audio.\n     */\n    redactedAudio(id) {\n        return this.fetchJson(`/v2/transcript/${id}/redacted-audio`);\n    }\n    /**\n     * Retrieve the redacted audio file of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the fetch HTTP response of the redacted audio file.\n     */\n    async redactedAudioFile(id) {\n        const { redacted_audio_url, status } = await this.redactedAudio(id);\n        if (status !== \"redacted_audio_ready\") {\n            throw new Error(`Redacted audio status is ${status}`);\n        }\n        const response = await fetch(redacted_audio_url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch redacted audio: ${response.statusText}`);\n        }\n        return {\n            arrayBuffer: response.arrayBuffer.bind(response),\n            blob: response.blob.bind(response),\n            body: response.body,\n            bodyUsed: response.bodyUsed,\n        };\n    }\n}\n\nconst readFile = async (path) => stream__WEBPACK_IMPORTED_MODULE_3__.Readable.toWeb((0,fs__WEBPACK_IMPORTED_MODULE_2__.createReadStream)(path));\n\nclass FileService extends BaseService {\n    /**\n     * Upload a local file to AssemblyAI.\n     * @param input - The local file path to upload, or a stream or buffer of the file to upload.\n     * @returns A promise that resolves to the uploaded file URL.\n     */\n    async upload(input) {\n        let fileData;\n        if (typeof input === \"string\") {\n            if (input.startsWith(\"data:\")) {\n                fileData = dataUrlToBlob(input);\n            }\n            else {\n                fileData = await readFile(input);\n            }\n        }\n        else\n            fileData = input;\n        const data = await this.fetchJson(\"/v2/upload\", {\n            method: \"POST\",\n            body: fileData,\n            headers: {\n                \"Content-Type\": \"application/octet-stream\",\n            },\n            duplex: \"half\",\n        });\n        return data.upload_url;\n    }\n}\nfunction dataUrlToBlob(dataUrl) {\n    const arr = dataUrl.split(\",\");\n    const mime = arr[0].match(/:(.*?);/)[1];\n    const bstr = atob(arr[1]);\n    let n = bstr.length;\n    const u8arr = new Uint8Array(n);\n    while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n    }\n    return new Blob([u8arr], { type: mime });\n}\n\nconst defaultStreamingUrl$1 = \"wss://streaming.assemblyai.com/v3/ws\";\nconst terminateSessionMessage = `{\"type\":\"Terminate\"}`;\nclass StreamingTranscriber {\n    constructor(params) {\n        this.listeners = {};\n        this.params = {\n            ...params,\n            websocketBaseUrl: params.websocketBaseUrl || defaultStreamingUrl$1,\n        };\n        if (\"token\" in params && params.token)\n            this.token = params.token;\n        if (\"apiKey\" in params && params.apiKey)\n            this.apiKey = params.apiKey;\n        if (!(this.token || this.apiKey)) {\n            throw new Error(\"API key or temporary token is required.\");\n        }\n    }\n    connectionUrl() {\n        const url = new URL(this.params.websocketBaseUrl ?? \"\");\n        if (url.protocol !== \"wss:\") {\n            throw new Error(\"Invalid protocol, must be wss\");\n        }\n        const searchParams = new URLSearchParams();\n        if (this.token) {\n            searchParams.set(\"token\", this.token);\n        }\n        searchParams.set(\"sample_rate\", this.params.sampleRate.toString());\n        if (this.params.endOfTurnConfidenceThreshold) {\n            searchParams.set(\"end_of_turn_confidence_threshold\", this.params.endOfTurnConfidenceThreshold.toString());\n        }\n        if (this.params.minEndOfTurnSilenceWhenConfident) {\n            searchParams.set(\"min_end_of_turn_silence_when_confident\", this.params.minEndOfTurnSilenceWhenConfident.toString());\n        }\n        if (this.params.maxTurnSilence) {\n            searchParams.set(\"max_turn_silence\", this.params.maxTurnSilence.toString());\n        }\n        if (this.params.formatTurns) {\n            searchParams.set(\"format_turns\", this.params.formatTurns.toString());\n        }\n        if (this.params.encoding) {\n            searchParams.set(\"encoding\", this.params.encoding.toString());\n        }\n        if (this.params.keytermsPrompt) {\n            searchParams.set(\"keyterms_prompt\", JSON.stringify(this.params.keytermsPrompt));\n        }\n        else if (this.params.keyterms) {\n            console.warn(\"[Deprecation Warning] `keyterms` is deprecated and will be removed in a future release. Please use `keytermsPrompt` instead.\");\n            searchParams.set(\"keyterms_prompt\", JSON.stringify(this.params.keyterms));\n        }\n        if (this.params.filterProfanity) {\n            searchParams.set(\"filter_profanity\", this.params.filterProfanity.toString());\n        }\n        url.search = searchParams.toString();\n        return url;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    on(event, listener) {\n        this.listeners[event] = listener;\n    }\n    connect() {\n        return new Promise((resolve) => {\n            if (this.socket) {\n                throw new Error(\"Already connected\");\n            }\n            const url = this.connectionUrl();\n            if (this.token) {\n                this.socket = factory(url.toString());\n            }\n            else {\n                this.socket = factory(url.toString(), {\n                    headers: { Authorization: this.apiKey },\n                });\n            }\n            this.socket.binaryType = \"arraybuffer\";\n            this.socket.onopen = () => { };\n            this.socket.onclose = ({ code, reason }) => {\n                if (!reason) {\n                    if (code in StreamingErrorMessages) {\n                        reason = StreamingErrorMessages[code];\n                    }\n                }\n                this.listeners.close?.(code, reason);\n            };\n            this.socket.onerror = (event) => {\n                if (event.error)\n                    this.listeners.error?.(event.error);\n                else\n                    this.listeners.error?.(new Error(event.message));\n            };\n            this.socket.onmessage = ({ data }) => {\n                const message = JSON.parse(data.toString());\n                if (\"error\" in message) {\n                    this.listeners.error?.(new StreamingError(message.error));\n                    return;\n                }\n                switch (message.type) {\n                    case \"Begin\": {\n                        resolve(message);\n                        this.listeners.open?.(message);\n                        break;\n                    }\n                    case \"Turn\": {\n                        this.listeners.turn?.(message);\n                        break;\n                    }\n                    case \"Termination\": {\n                        this.sessionTerminatedResolve?.();\n                        break;\n                    }\n                }\n            };\n        });\n    }\n    stream() {\n        return new stream_web__WEBPACK_IMPORTED_MODULE_0__.WritableStream({\n            write: (chunk) => {\n                this.sendAudio(chunk);\n            },\n        });\n    }\n    sendAudio(audio) {\n        this.send(audio);\n    }\n    send(data) {\n        if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n            throw new Error(\"Socket is not open for communication\");\n        }\n        this.socket.send(data);\n    }\n    async close(waitForSessionTermination = true) {\n        if (this.socket) {\n            if (this.socket.readyState === this.socket.OPEN) {\n                if (waitForSessionTermination) {\n                    const sessionTerminatedPromise = new Promise((resolve) => {\n                        this.sessionTerminatedResolve = resolve;\n                    });\n                    this.socket.send(terminateSessionMessage);\n                    await sessionTerminatedPromise;\n                }\n                else {\n                    this.socket.send(terminateSessionMessage);\n                }\n            }\n            if (this.socket?.removeAllListeners)\n                this.socket.removeAllListeners();\n            this.socket.close();\n        }\n        this.listeners = {};\n        this.socket = undefined;\n    }\n}\n\nclass StreamingTranscriberFactory extends BaseService {\n    constructor(params) {\n        super(params);\n        this.baseServiceParams = params;\n    }\n    transcriber(params) {\n        const serviceParams = { ...params };\n        if (!serviceParams.token && !serviceParams.apiKey) {\n            serviceParams.apiKey = this.baseServiceParams.apiKey;\n        }\n        return new StreamingTranscriber(serviceParams);\n    }\n    async createTemporaryToken(params) {\n        const searchParams = new URLSearchParams();\n        // Add each param to the search params\n        Object.entries(params).forEach(([key, value]) => {\n            if (value !== undefined && value !== null) {\n                searchParams.append(key, String(value));\n            }\n        });\n        const queryString = searchParams.toString();\n        const url = queryString ? `/v3/token?${queryString}` : \"/v3/token\";\n        const data = await this.fetchJson(url, {\n            method: \"GET\",\n        });\n        return data.token;\n    }\n}\n\nconst defaultBaseUrl = \"https://api.assemblyai.com\";\nconst defaultStreamingUrl = \"https://streaming.assemblyai.com\";\nclass AssemblyAI {\n    /**\n     * Create a new AssemblyAI client.\n     * @param params - The parameters for the service, including the API key and base URL, if any.\n     */\n    constructor(params) {\n        params.baseUrl = params.baseUrl || defaultBaseUrl;\n        if (params.baseUrl && params.baseUrl.endsWith(\"/\")) {\n            params.baseUrl = params.baseUrl.slice(0, -1);\n        }\n        this.files = new FileService(params);\n        this.transcripts = new TranscriptService(params, this.files);\n        this.lemur = new LemurService(params);\n        this.realtime = new RealtimeTranscriberFactory(params);\n        this.streaming = new StreamingTranscriberFactory({\n            ...params,\n            baseUrl: params.streamingBaseUrl || defaultStreamingUrl,\n        });\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNzZW1ibHlhaS9kaXN0L25vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEM7QUFDeEI7QUFDa0I7QUFDSjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRSxnREFBZ0QsSUFBSSxHQUFHLFVBQVUsR0FBRyxhQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQixFQUFFLG9CQUFvQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEscUNBQXFDLDBDQUFFOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQywyQkFBMkI7QUFDaEUsb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFb0wiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSnVzdCBUXFxEb3dubG9hZHNcXGRhcHVyX2dlbmllX3NyY19jb2RlXFx3ZS1kb250LWhhdmUtYS10ZWFtLW5hbWVcXG5vLWF3cy1kYXB1ci1nZW5pZVxcbm9kZV9tb2R1bGVzXFxhc3NlbWJseWFpXFxkaXN0XFxub2RlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXcml0YWJsZVN0cmVhbSB9IGZyb20gJ3N0cmVhbS93ZWInO1xuaW1wb3J0IHdzIGZyb20gJ3dzJztcbmltcG9ydCB7IGNyZWF0ZVJlYWRTdHJlYW0gfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5cbmNvbnN0IERFRkFVTFRfRkVUQ0hfSU5JVCA9IHtcbiAgICBjYWNoZTogXCJuby1zdG9yZVwiLFxufTtcblxuY29uc3QgYnVpbGRVc2VyQWdlbnQgPSAodXNlckFnZW50KSA9PiBkZWZhdWx0VXNlckFnZW50U3RyaW5nICtcbiAgICAodXNlckFnZW50ID09PSBmYWxzZVxuICAgICAgICA/IFwiXCJcbiAgICAgICAgOiBcIiBBc3NlbWJseUFJLzEuMCAoXCIgK1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoeyAuLi5kZWZhdWx0VXNlckFnZW50LCAuLi51c2VyQWdlbnQgfSlcbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCBpdGVtXSkgPT4gaXRlbSA/IGAke2tleX09JHtpdGVtLm5hbWV9LyR7aXRlbS52ZXJzaW9ufWAgOiBcIlwiKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiIFwiKSArXG4gICAgICAgICAgICBcIilcIik7XG5sZXQgZGVmYXVsdFVzZXJBZ2VudFN0cmluZyA9IFwiXCI7XG5pZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgZGVmYXVsdFVzZXJBZ2VudFN0cmluZyArPSBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuY29uc3QgZGVmYXVsdFVzZXJBZ2VudCA9IHtcbiAgICBzZGs6IHsgbmFtZTogXCJKYXZhU2NyaXB0XCIsIHZlcnNpb246IFwiNC4xNi4xXCIgfSxcbn07XG5pZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAocHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmIGRlZmF1bHRVc2VyQWdlbnRTdHJpbmcuaW5kZXhPZihcIk5vZGVcIikgPT09IC0xKSB7XG4gICAgICAgIGRlZmF1bHRVc2VyQWdlbnQucnVudGltZV9lbnYgPSB7XG4gICAgICAgICAgICBuYW1lOiBcIk5vZGVcIixcbiAgICAgICAgICAgIHZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MudmVyc2lvbnMuYnVuICYmIGRlZmF1bHRVc2VyQWdlbnRTdHJpbmcuaW5kZXhPZihcIkJ1blwiKSA9PT0gLTEpIHtcbiAgICAgICAgZGVmYXVsdFVzZXJBZ2VudC5ydW50aW1lX2VudiA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiQnVuXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiBwcm9jZXNzLnZlcnNpb25zLmJ1bixcbiAgICAgICAgfTtcbiAgICB9XG59XG5pZiAodHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAocHJvY2Vzcy52ZXJzaW9ucy5idW4gJiYgZGVmYXVsdFVzZXJBZ2VudFN0cmluZy5pbmRleE9mKFwiRGVub1wiKSA9PT0gLTEpIHtcbiAgICAgICAgZGVmYXVsdFVzZXJBZ2VudC5ydW50aW1lX2VudiA9IHsgbmFtZTogXCJEZW5vXCIsIHZlcnNpb246IERlbm8udmVyc2lvbi5kZW5vIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHNlcnZpY2VzIHRoYXQgY29tbXVuaWNhdGUgd2l0aCB0aGUgQVBJLlxuICovXG5jbGFzcyBCYXNlU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlcnZpY2UuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgdGhlIHNlcnZpY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBpZiAocGFyYW1zLnVzZXJBZ2VudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBidWlsZFVzZXJBZ2VudChwYXJhbXMudXNlckFnZW50IHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgICAgICBpbml0ID0geyAuLi5ERUZBVUxUX0ZFVENIX0lOSVQsIC4uLmluaXQgfTtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzLnBhcmFtcy5hcGlLZXksXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKERFRkFVTFRfRkVUQ0hfSU5JVD8uaGVhZGVycylcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7IC4uLmhlYWRlcnMsIC4uLkRFRkFVTFRfRkVUQ0hfSU5JVC5oZWFkZXJzIH07XG4gICAgICAgIGlmIChpbml0Py5oZWFkZXJzKVxuICAgICAgICAgICAgaGVhZGVycyA9IHsgLi4uaGVhZGVycywgLi4uaW5pdC5oZWFkZXJzIH07XG4gICAgICAgIGlmICh0aGlzLnVzZXJBZ2VudCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPSB0aGlzLnVzZXJBZ2VudDtcbiAgICAgICAgfVxuICAgICAgICBpbml0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICBpZiAoIWlucHV0LnN0YXJ0c1dpdGgoXCJodHRwXCIpKVxuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnBhcmFtcy5iYXNlVXJsICsgaW5wdXQ7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaW5wdXQsIGluaXQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgbGV0IGpzb247XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbj8uZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihqc29uLmVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaEpzb24oaW5wdXQsIGluaXQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKGlucHV0LCBpbml0KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG59XG5cbmNsYXNzIExlbXVyU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIHtcbiAgICBzdW1tYXJ5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oXCIvbGVtdXIvdjMvZ2VuZXJhdGUvc3VtbWFyeVwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXN0aW9uQW5zd2VyKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oXCIvbGVtdXIvdjMvZ2VuZXJhdGUvcXVlc3Rpb24tYW5zd2VyXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWN0aW9uSXRlbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihcIi9sZW11ci92My9nZW5lcmF0ZS9hY3Rpb24taXRlbXNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0YXNrKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oXCIvbGVtdXIvdjMvZ2VuZXJhdGUvdGFza1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlc3BvbnNlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihgL2xlbXVyL3YzLyR7aWR9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgZGF0YSBmb3IgYSBwcmV2aW91c2x5IHN1Ym1pdHRlZCBMZU1VUiByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBpZCAtIElEIG9mIHRoZSBMZU1VUiByZXF1ZXN0XG4gICAgICovXG4gICAgcHVyZ2VSZXF1ZXN0RGF0YShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC9sZW11ci92My8ke2lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBmYWN0b3J5ID0gKHVybCwgcGFyYW1zKSA9PiBuZXcgd3ModXJsLCBwYXJhbXMpO1xuXG5jb25zdCBSZWFsdGltZUVycm9yVHlwZSA9IHtcbiAgICBCYWRTYW1wbGVSYXRlOiA0MDAwLFxuICAgIEF1dGhGYWlsZWQ6IDQwMDEsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIEluc3VmZmljaWVudEZ1bmRzIG9yIEZyZWVUaWVyVXNlciBpbnN0ZWFkXG4gICAgICovXG4gICAgSW5zdWZmaWNpZW50RnVuZHNPckZyZWVBY2NvdW50OiA0MDAyLFxuICAgIEluc3VmZmljaWVudEZ1bmRzOiA0MDAyLFxuICAgIEZyZWVUaWVyVXNlcjogNDAwMyxcbiAgICBOb25leGlzdGVudFNlc3Npb25JZDogNDAwNCxcbiAgICBTZXNzaW9uRXhwaXJlZDogNDAwOCxcbiAgICBDbG9zZWRTZXNzaW9uOiA0MDEwLFxuICAgIFJhdGVMaW1pdGVkOiA0MDI5LFxuICAgIFVuaXF1ZVNlc3Npb25WaW9sYXRpb246IDQwMzAsXG4gICAgU2Vzc2lvblRpbWVvdXQ6IDQwMzEsXG4gICAgQXVkaW9Ub29TaG9ydDogNDAzMixcbiAgICBBdWRpb1Rvb0xvbmc6IDQwMzMsXG4gICAgQXVkaW9Ub29TbWFsbFRvVHJhbnNjb2RlOiA0MDM0LFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERvbid0IHVzZVxuICAgICAqL1xuICAgIEJhZEpzb246IDQxMDAsXG4gICAgQmFkU2NoZW1hOiA0MTAxLFxuICAgIFRvb01hbnlTdHJlYW1zOiA0MTAyLFxuICAgIFJlY29ubmVjdGVkOiA0MTAzLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERvbid0IHVzZVxuICAgICAqL1xuICAgIFJlY29ubmVjdEF0dGVtcHRzRXhoYXVzdGVkOiAxMDEzLFxuICAgIFdvcmRCb29zdFBhcmFtZXRlclBhcnNpbmdGYWlsZWQ6IDQxMDQsXG59O1xuY29uc3QgUmVhbHRpbWVFcnJvck1lc3NhZ2VzID0ge1xuICAgIFtSZWFsdGltZUVycm9yVHlwZS5CYWRTYW1wbGVSYXRlXTogXCJTYW1wbGUgcmF0ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5BdXRoRmFpbGVkXTogXCJOb3QgQXV0aG9yaXplZFwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5JbnN1ZmZpY2llbnRGdW5kc106IFwiSW5zdWZmaWNpZW50IGZ1bmRzXCIsXG4gICAgW1JlYWx0aW1lRXJyb3JUeXBlLkZyZWVUaWVyVXNlcl06IFwiVGhpcyBmZWF0dXJlIGlzIHBhaWQtb25seSBhbmQgcmVxdWlyZXMgeW91IHRvIGFkZCBhIGNyZWRpdCBjYXJkLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9hcHAuYXNzZW1ibHlhaS5jb20vIHRvIGFkZCBhIGNyZWRpdCBjYXJkIHRvIHlvdXIgYWNjb3VudC5cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuTm9uZXhpc3RlbnRTZXNzaW9uSWRdOiBcIlNlc3Npb24gSUQgZG9lcyBub3QgZXhpc3RcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuU2Vzc2lvbkV4cGlyZWRdOiBcIlNlc3Npb24gaGFzIGV4cGlyZWRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQ2xvc2VkU2Vzc2lvbl06IFwiU2Vzc2lvbiBpcyBjbG9zZWRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuUmF0ZUxpbWl0ZWRdOiBcIlJhdGUgbGltaXRlZFwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5VbmlxdWVTZXNzaW9uVmlvbGF0aW9uXTogXCJVbmlxdWUgc2Vzc2lvbiB2aW9sYXRpb25cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuU2Vzc2lvblRpbWVvdXRdOiBcIlNlc3Npb24gVGltZW91dFwiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5BdWRpb1Rvb1Nob3J0XTogXCJBdWRpbyB0b28gc2hvcnRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQXVkaW9Ub29Mb25nXTogXCJBdWRpbyB0b28gbG9uZ1wiLFxuICAgIFtSZWFsdGltZUVycm9yVHlwZS5BdWRpb1Rvb1NtYWxsVG9UcmFuc2NvZGVdOiBcIkF1ZGlvIHRvbyBzbWFsbCB0byB0cmFuc2NvZGVcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQmFkSnNvbl06IFwiQmFkIEpTT05cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuQmFkU2NoZW1hXTogXCJCYWQgc2NoZW1hXCIsXG4gICAgW1JlYWx0aW1lRXJyb3JUeXBlLlRvb01hbnlTdHJlYW1zXTogXCJUb28gbWFueSBzdHJlYW1zXCIsXG4gICAgW1JlYWx0aW1lRXJyb3JUeXBlLlJlY29ubmVjdGVkXTogXCJUaGlzIHNlc3Npb24gaGFzIGJlZW4gcmVjb25uZWN0ZWQuIFRoaXMgV2ViU29ja2V0IGlzIG5vIGxvbmdlciB2YWxpZC5cIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuUmVjb25uZWN0QXR0ZW1wdHNFeGhhdXN0ZWRdOiBcIlJlY29ubmVjdCBhdHRlbXB0cyBleGhhdXN0ZWRcIixcbiAgICBbUmVhbHRpbWVFcnJvclR5cGUuV29yZEJvb3N0UGFyYW1ldGVyUGFyc2luZ0ZhaWxlZF06IFwiQ291bGQgbm90IHBhcnNlIHdvcmQgYm9vc3QgcGFyYW1ldGVyXCIsXG59O1xuY2xhc3MgUmVhbHRpbWVFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cblxuY29uc3QgU3RyZWFtaW5nRXJyb3JUeXBlID0ge1xuICAgIEJhZFNhbXBsZVJhdGU6IDQwMDAsXG4gICAgQXV0aEZhaWxlZDogNDAwMSxcbiAgICBJbnN1ZmZpY2llbnRGdW5kczogNDAwMixcbiAgICBGcmVlVGllclVzZXI6IDQwMDMsXG4gICAgTm9uZXhpc3RlbnRTZXNzaW9uSWQ6IDQwMDQsXG4gICAgU2Vzc2lvbkV4cGlyZWQ6IDQwMDgsXG4gICAgQ2xvc2VkU2Vzc2lvbjogNDAxMCxcbiAgICBSYXRlTGltaXRlZDogNDAyOSxcbiAgICBVbmlxdWVTZXNzaW9uVmlvbGF0aW9uOiA0MDMwLFxuICAgIFNlc3Npb25UaW1lb3V0OiA0MDMxLFxuICAgIEF1ZGlvVG9vU2hvcnQ6IDQwMzIsXG4gICAgQXVkaW9Ub29Mb25nOiA0MDMzLFxuICAgIEF1ZGlvVG9vU21hbGxUb1RyYW5zY29kZTogNDAzNCxcbiAgICBCYWRTY2hlbWE6IDQxMDEsXG4gICAgVG9vTWFueVN0cmVhbXM6IDQxMDIsXG4gICAgUmVjb25uZWN0ZWQ6IDQxMDMsXG59O1xuY29uc3QgU3RyZWFtaW5nRXJyb3JNZXNzYWdlcyA9IHtcbiAgICBbU3RyZWFtaW5nRXJyb3JUeXBlLkJhZFNhbXBsZVJhdGVdOiBcIlNhbXBsZSByYXRlIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIsXG4gICAgW1N0cmVhbWluZ0Vycm9yVHlwZS5BdXRoRmFpbGVkXTogXCJOb3QgQXV0aG9yaXplZFwiLFxuICAgIFtTdHJlYW1pbmdFcnJvclR5cGUuSW5zdWZmaWNpZW50RnVuZHNdOiBcIkluc3VmZmljaWVudCBmdW5kc1wiLFxuICAgIFtTdHJlYW1pbmdFcnJvclR5cGUuRnJlZVRpZXJVc2VyXTogXCJUaGlzIGZlYXR1cmUgaXMgcGFpZC1vbmx5IGFuZCByZXF1aXJlcyB5b3UgdG8gYWRkIGEgY3JlZGl0IGNhcmQuIFBsZWFzZSB2aXNpdCBodHRwczovL2FwcC5hc3NlbWJseWFpLmNvbS8gdG8gYWRkIGEgY3JlZGl0IGNhcmQgdG8geW91ciBhY2NvdW50LlwiLFxuICAgIFtTdHJlYW1pbmdFcnJvclR5cGUuTm9uZXhpc3RlbnRTZXNzaW9uSWRdOiBcIlNlc3Npb24gSUQgZG9lcyBub3QgZXhpc3RcIixcbiAgICBbU3RyZWFtaW5nRXJyb3JUeXBlLlNlc3Npb25FeHBpcmVkXTogXCJTZXNzaW9uIGhhcyBleHBpcmVkXCIsXG4gICAgW1N0cmVhbWluZ0Vycm9yVHlwZS5DbG9zZWRTZXNzaW9uXTogXCJTZXNzaW9uIGlzIGNsb3NlZFwiLFxuICAgIFtTdHJlYW1pbmdFcnJvclR5cGUuUmF0ZUxpbWl0ZWRdOiBcIlJhdGUgbGltaXRlZFwiLFxuICAgIFtTdHJlYW1pbmdFcnJvclR5cGUuVW5pcXVlU2Vzc2lvblZpb2xhdGlvbl06IFwiVW5pcXVlIHNlc3Npb24gdmlvbGF0aW9uXCIsXG4gICAgW1N0cmVhbWluZ0Vycm9yVHlwZS5TZXNzaW9uVGltZW91dF06IFwiU2Vzc2lvbiBUaW1lb3V0XCIsXG4gICAgW1N0cmVhbWluZ0Vycm9yVHlwZS5BdWRpb1Rvb1Nob3J0XTogXCJBdWRpbyB0b28gc2hvcnRcIixcbiAgICBbU3RyZWFtaW5nRXJyb3JUeXBlLkF1ZGlvVG9vTG9uZ106IFwiQXVkaW8gdG9vIGxvbmdcIixcbiAgICBbU3RyZWFtaW5nRXJyb3JUeXBlLkF1ZGlvVG9vU21hbGxUb1RyYW5zY29kZV06IFwiQXVkaW8gdG9vIHNtYWxsIHRvIHRyYW5zY29kZVwiLFxuICAgIFtTdHJlYW1pbmdFcnJvclR5cGUuQmFkU2NoZW1hXTogXCJCYWQgc2NoZW1hXCIsXG4gICAgW1N0cmVhbWluZ0Vycm9yVHlwZS5Ub29NYW55U3RyZWFtc106IFwiVG9vIG1hbnkgc3RyZWFtc1wiLFxuICAgIFtTdHJlYW1pbmdFcnJvclR5cGUuUmVjb25uZWN0ZWRdOiBcIlRoaXMgc2Vzc2lvbiBoYXMgYmVlbiByZWNvbm5lY3RlZC4gVGhpcyBXZWJTb2NrZXQgaXMgbm8gbG9uZ2VyIHZhbGlkLlwiLFxufTtcbmNsYXNzIFN0cmVhbWluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jb25zdCBkZWZhdWx0UmVhbHRpbWVVcmwgPSBcIndzczovL2FwaS5hc3NlbWJseWFpLmNvbS92Mi9yZWFsdGltZS93c1wiO1xuY29uc3QgZm9yY2VFbmRPZlV0dGVyYW5jZU1lc3NhZ2UgPSBge1wiZm9yY2VfZW5kX3V0dGVyYW5jZVwiOnRydWV9YDtcbmNvbnN0IHRlcm1pbmF0ZVNlc3Npb25NZXNzYWdlJDEgPSBge1widGVybWluYXRlX3Nlc3Npb25cIjp0cnVlfWA7XG4vKipcbiAqIFJlYWx0aW1lVHJhbnNjcmliZXIgY29ubmVjdHMgdG8gdGhlIFN0cmVhbWluZyBTcGVlY2gtdG8tVGV4dCBBUEkgYW5kIGxldHMgeW91IHRyYW5zY3JpYmUgYXVkaW8gaW4gcmVhbC10aW1lLlxuICovXG5jbGFzcyBSZWFsdGltZVRyYW5zY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUmVhbHRpbWVUcmFuc2NyaWJlci5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyB0byBjb25maWd1cmUgdGhlIFJlYWx0aW1lVHJhbnNjcmliZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWFsdGltZVVybCA9IHBhcmFtcy5yZWFsdGltZVVybCA/PyBkZWZhdWx0UmVhbHRpbWVVcmw7XG4gICAgICAgIHRoaXMuc2FtcGxlUmF0ZSA9IHBhcmFtcy5zYW1wbGVSYXRlID8/IDE2XzAwMDtcbiAgICAgICAgdGhpcy53b3JkQm9vc3QgPSBwYXJhbXMud29yZEJvb3N0O1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gcGFyYW1zLmVuY29kaW5nO1xuICAgICAgICB0aGlzLmVuZFV0dGVyYW5jZVNpbGVuY2VUaHJlc2hvbGQgPSBwYXJhbXMuZW5kVXR0ZXJhbmNlU2lsZW5jZVRocmVzaG9sZDtcbiAgICAgICAgdGhpcy5kaXNhYmxlUGFydGlhbFRyYW5zY3JpcHRzID0gcGFyYW1zLmRpc2FibGVQYXJ0aWFsVHJhbnNjcmlwdHM7XG4gICAgICAgIGlmIChcInRva2VuXCIgaW4gcGFyYW1zICYmIHBhcmFtcy50b2tlbilcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBwYXJhbXMudG9rZW47XG4gICAgICAgIGlmIChcImFwaUtleVwiIGluIHBhcmFtcyAmJiBwYXJhbXMuYXBpS2V5KVxuICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSBwYXJhbXMuYXBpS2V5O1xuICAgICAgICBpZiAoISh0aGlzLnRva2VuIHx8IHRoaXMuYXBpS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQVBJIGtleSBvciB0ZW1wb3JhcnkgdG9rZW4gaXMgcmVxdWlyZWQuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3Rpb25VcmwoKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5yZWFsdGltZVVybCk7XG4gICAgICAgIGlmICh1cmwucHJvdG9jb2wgIT09IFwid3NzOlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3RvY29sLCBtdXN0IGJlIHdzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwidG9rZW5cIiwgdGhpcy50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoUGFyYW1zLnNldChcInNhbXBsZV9yYXRlXCIsIHRoaXMuc2FtcGxlUmF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHRoaXMud29yZEJvb3N0ICYmIHRoaXMud29yZEJvb3N0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJ3b3JkX2Jvb3N0XCIsIEpTT04uc3RyaW5naWZ5KHRoaXMud29yZEJvb3N0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJlbmNvZGluZ1wiLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwiZW5hYmxlX2V4dHJhX3Nlc3Npb25faW5mb3JtYXRpb25cIiwgXCJ0cnVlXCIpO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlUGFydGlhbFRyYW5zY3JpcHRzKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwiZGlzYWJsZV9wYXJ0aWFsX3RyYW5zY3JpcHRzXCIsIHRoaXMuZGlzYWJsZVBhcnRpYWxUcmFuc2NyaXB0cy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwuc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZvciBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBzZXJ2ZXIgYW5kIGJlZ2luIGEgbmV3IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCBhbmQgdGhlIHNlc3Npb24gYmVnaW5zLlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbm5lY3Rpb25VcmwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBmYWN0b3J5KHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gZmFjdG9yeSh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IHRoaXMuYXBpS2V5IH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZFV0dGVyYW5jZVNpbGVuY2VUaHJlc2hvbGQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFV0dGVyYW5jZVNpbGVuY2VUaHJlc2hvbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUVuZFV0dGVyYW5jZVNpbGVuY2VUaHJlc2hvbGQodGhpcy5lbmRVdHRlcmFuY2VTaWxlbmNlVGhyZXNob2xkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gKHsgY29kZSwgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSBpbiBSZWFsdGltZUVycm9yTWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFJlYWx0aW1lRXJyb3JNZXNzYWdlc1tjb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5jbG9zZT8uKGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZXJyb3I/LihldmVudC5lcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5lcnJvcj8uKG5ldyBFcnJvcihldmVudC5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZXJyb3I/LihuZXcgUmVhbHRpbWVFcnJvcihtZXNzYWdlLmVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLm1lc3NhZ2VfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU2Vzc2lvbkJlZ2luc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVuT2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogbWVzc2FnZS5zZXNzaW9uX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUobWVzc2FnZS5leHBpcmVzX2F0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9wZW5PYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMub3Blbj8uKG9wZW5PYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlBhcnRpYWxUcmFuc2NyaXB0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UuY3JlYXRlZCBpcyBhY3R1YWxseSBhIHN0cmluZyB3aGVuIGNvbWluZyBmcm9tIHRoZSBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZCA9IG5ldyBEYXRlKG1lc3NhZ2UuY3JlYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy50cmFuc2NyaXB0Py4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tcInRyYW5zY3JpcHQucGFydGlhbFwiXT8uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkZpbmFsVHJhbnNjcmlwdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlLmNyZWF0ZWQgaXMgYWN0dWFsbHkgYSBzdHJpbmcgd2hlbiBjb21pbmcgZnJvbSB0aGUgc29ja2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWQgPSBuZXcgRGF0ZShtZXNzYWdlLmNyZWF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMudHJhbnNjcmlwdD8uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbXCJ0cmFuc2NyaXB0LmZpbmFsXCJdPy4obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU2Vzc2lvbkluZm9ybWF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNlc3Npb25faW5mb3JtYXRpb24/LihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTZXNzaW9uVGVybWluYXRlZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25UZXJtaW5hdGVkUmVzb2x2ZT8uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGF1ZGlvIGRhdGEgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gYXVkaW8gLSBUaGUgYXVkaW8gZGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgc2VuZEF1ZGlvKGF1ZGlvKSB7XG4gICAgICAgIHRoaXMuc2VuZChhdWRpbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1c2VkIHRvIHNlbmQgYXVkaW8gZGF0YSB0byB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm5zIEEgd3JpdGFibGUgc3RyZWFtIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VuZCBhdWRpbyBkYXRhIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgc3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlOiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRBdWRpbyhjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgZW5kIGFuIHV0dGVyYW5jZVxuICAgICAqL1xuICAgIGZvcmNlRW5kVXR0ZXJhbmNlKCkge1xuICAgICAgICB0aGlzLnNlbmQoZm9yY2VFbmRPZlV0dGVyYW5jZU1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIHRocmVzaG9sZCBmb3IgaG93IGxvbmcgdG8gd2FpdCBiZWZvcmUgZW5kaW5nIGFuIHV0dGVyYW5jZS4gRGVmYXVsdCBpcyA3MDBtcy5cbiAgICAgKiBAcGFyYW0gdGhyZXNob2xkIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSBlbmQgdXR0ZXJhbmNlIHNpbGVuY2UgdGhyZXNob2xkIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBUaGlzIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDIwXzAwMC5cbiAgICAgKi9cbiAgICBjb25maWd1cmVFbmRVdHRlcmFuY2VTaWxlbmNlVGhyZXNob2xkKHRocmVzaG9sZCkge1xuICAgICAgICB0aGlzLnNlbmQoYHtcImVuZF91dHRlcmFuY2Vfc2lsZW5jZV90aHJlc2hvbGRcIjoke3RocmVzaG9sZH19YCk7XG4gICAgfVxuICAgIHNlbmQoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuc29ja2V0IHx8IHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgIT09IHRoaXMuc29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvY2tldCBpcyBub3Qgb3BlbiBmb3IgY29tbXVuaWNhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB3YWl0Rm9yU2Vzc2lvblRlcm1pbmF0aW9uIC0gSWYgdHJ1ZSwgdGhlIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBzZXNzaW9uIHRvIGJlIHRlcm1pbmF0ZWQgYmVmb3JlIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uXG4gICAgICogV2hpbGUgd2FpdGluZyBmb3IgdGhlIHNlc3Npb24gdG8gYmUgdGVybWluYXRlZCwgeW91IHdpbGwgcmVjZWl2ZSB0aGUgZmluYWwgdHJhbnNjcmlwdCBhbmQgc2Vzc2lvbiBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSh3YWl0Rm9yU2Vzc2lvblRlcm1pbmF0aW9uID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldC5yZWFkeVN0YXRlID09PSB0aGlzLnNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhaXRGb3JTZXNzaW9uVGVybWluYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblRlcm1pbmF0ZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvblRlcm1pbmF0ZWRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQodGVybWluYXRlU2Vzc2lvbk1lc3NhZ2UkMSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlc3Npb25UZXJtaW5hdGVkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQodGVybWluYXRlU2Vzc2lvbk1lc3NhZ2UkMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0Py5yZW1vdmVBbGxMaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMuc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIFJlYWx0aW1lVHJhbnNjcmliZXIgaW5zdGVhZFxuICovXG5jbGFzcyBSZWFsdGltZVNlcnZpY2UgZXh0ZW5kcyBSZWFsdGltZVRyYW5zY3JpYmVyIHtcbn1cblxuY2xhc3MgUmVhbHRpbWVUcmFuc2NyaWJlckZhY3RvcnkgZXh0ZW5kcyBCYXNlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIHRoaXMucnRGYWN0b3J5UGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdHJhbnNjcmliZXIoLi4uKSBpbnN0ZWFkXG4gICAgICovXG4gICAgY3JlYXRlU2VydmljZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNjcmliZXIocGFyYW1zKTtcbiAgICB9XG4gICAgdHJhbnNjcmliZXIocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VQYXJhbXMgPSB7IC4uLnBhcmFtcyB9O1xuICAgICAgICBpZiAoIXNlcnZpY2VQYXJhbXMudG9rZW4gJiYgIXNlcnZpY2VQYXJhbXMuYXBpS2V5KSB7XG4gICAgICAgICAgICBzZXJ2aWNlUGFyYW1zLmFwaUtleSA9IHRoaXMucnRGYWN0b3J5UGFyYW1zLmFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlYWx0aW1lVHJhbnNjcmliZXIoc2VydmljZVBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVRlbXBvcmFyeVRva2VuKHBhcmFtcykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaEpzb24oXCIvdjIvcmVhbHRpbWUvdG9rZW5cIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YS50b2tlbjtcbiAgICB9XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBSZWFsdGltZVRyYW5zY3JpYmVyRmFjdG9yeSBpbnN0ZWFkXG4gKi9cbmNsYXNzIFJlYWx0aW1lU2VydmljZUZhY3RvcnkgZXh0ZW5kcyBSZWFsdGltZVRyYW5zY3JpYmVyRmFjdG9yeSB7XG59XG5cbmZ1bmN0aW9uIGdldFBhdGgocGF0aCkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJodHRwXCIpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiaHR0cHNcIikpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpXG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZyg3KTtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiZmlsZTpcIikpXG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZyg1KTtcbiAgICByZXR1cm4gcGF0aDtcbn1cblxuY2xhc3MgVHJhbnNjcmlwdFNlcnZpY2UgZXh0ZW5kcyBCYXNlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBmaWxlcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICB0aGlzLmZpbGVzID0gZmlsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zY3JpYmUgYW4gYXVkaW8gZmlsZS4gVGhpcyB3aWxsIGNyZWF0ZSBhIHRyYW5zY3JpcHQgYW5kIHdhaXQgdW50aWwgdGhlIHRyYW5zY3JpcHQgc3RhdHVzIGlzIFwiY29tcGxldGVkXCIgb3IgXCJlcnJvclwiLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byB0cmFuc2NyaWJlIGFuIGF1ZGlvIGZpbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB0cmFuc2NyaWJlIGFuIGF1ZGlvIGZpbGUuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zY3JpcHQuIFRoZSB0cmFuc2NyaXB0IHN0YXR1cyBpcyBcImNvbXBsZXRlZFwiIG9yIFwiZXJyb3JcIi5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2NyaWJlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gYXdhaXQgdGhpcy5zdWJtaXQocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud2FpdFVudGlsUmVhZHkodHJhbnNjcmlwdC5pZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdHMgYSB0cmFuc2NyaXB0aW9uIGpvYiBmb3IgYW4gYXVkaW8gZmlsZS4gVGhpcyB3aWxsIG5vdCB3YWl0IHVudGlsIHRoZSB0cmFuc2NyaXB0IHN0YXR1cyBpcyBcImNvbXBsZXRlZFwiIG9yIFwiZXJyb3JcIi5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gc3RhcnQgdGhlIHRyYW5zY3JpcHRpb24gb2YgYW4gYXVkaW8gZmlsZS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcXVldWVkIHRyYW5zY3JpcHQuXG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0KHBhcmFtcykge1xuICAgICAgICBsZXQgYXVkaW9Vcmw7XG4gICAgICAgIGxldCB0cmFuc2NyaXB0UGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoXCJhdWRpb1wiIGluIHBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgeyBhdWRpbywgLi4uYXVkaW9UcmFuc2NyaXB0UGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1ZGlvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGdldFBhdGgoYXVkaW8pO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF1ZGlvIGlzIGxvY2FsIHBhdGgsIHVwbG9hZCBsb2NhbCBmaWxlXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvVXJsID0gYXdhaXQgdGhpcy5maWxlcy51cGxvYWQocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW8uc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb1VybCA9IGF3YWl0IHRoaXMuZmlsZXMudXBsb2FkKGF1ZGlvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1ZGlvIGlzIG5vdCBhIGxvY2FsIHBhdGgsIGFuZCBub3QgYSBkYXRhLVVSSSwgYXNzdW1lIGl0J3MgYSBub3JtYWwgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb1VybCA9IGF1ZGlvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXVkaW8gaXMgb2YgdXBsb2FkYWJsZSB0eXBlXG4gICAgICAgICAgICAgICAgYXVkaW9VcmwgPSBhd2FpdCB0aGlzLmZpbGVzLnVwbG9hZChhdWRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2NyaXB0UGFyYW1zID0geyAuLi5hdWRpb1RyYW5zY3JpcHRQYXJhbXMsIGF1ZGlvX3VybDogYXVkaW9VcmwgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zY3JpcHRQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hKc29uKFwiL3YyL3RyYW5zY3JpcHRcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRyYW5zY3JpcHRQYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB1c2VkIGZvciBjcmVhdGluZyB0aGUgbmV3IHRyYW5zY3JpcHQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB0cmFuc2NyaWJlYCBpbnN0ZWFkIHRvIHRyYW5zY3JpYmUgYSBhdWRpbyBmaWxlIHRoYXQgaW5jbHVkZXMgcG9sbGluZywgb3IgYHN1Ym1pdGAgdG8gdHJhbnNjcmliZSBhIGF1ZGlvIGZpbGUgd2l0aG91dCBwb2xsaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGdldFBhdGgocGFyYW1zLmF1ZGlvX3VybCk7XG4gICAgICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZpbGVzLnVwbG9hZChwYXRoKTtcbiAgICAgICAgICAgIHBhcmFtcy5hdWRpb191cmwgPSB1cGxvYWRVcmw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hKc29uKFwiL3YyL3RyYW5zY3JpcHRcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucz8ucG9sbCA/PyB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy53YWl0VW50aWxSZWFkeShkYXRhLmlkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCB1bnRpbCB0aGUgdHJhbnNjcmlwdCByZWFkeSwgZWl0aGVyIHRoZSBzdGF0dXMgaXMgXCJjb21wbGV0ZWRcIiBvciBcImVycm9yXCIuXG4gICAgICogQHBhcmFtIHRyYW5zY3JpcHRJZCAtIFRoZSBJRCBvZiB0aGUgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHdhaXQgdW50aWwgdGhlIHRyYW5zY3JpcHQgaXMgcmVhZHkuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zY3JpcHQuIFRoZSB0cmFuc2NyaXB0IHN0YXR1cyBpcyBcImNvbXBsZXRlZFwiIG9yIFwiZXJyb3JcIi5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0VW50aWxSZWFkeSh0cmFuc2NyaXB0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcG9sbGluZ0ludGVydmFsID0gb3B0aW9ucz8ucG9sbGluZ0ludGVydmFsID8/IDNfMDAwO1xuICAgICAgICBjb25zdCBwb2xsaW5nVGltZW91dCA9IG9wdGlvbnM/LnBvbGxpbmdUaW1lb3V0ID8/IC0xO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gYXdhaXQgdGhpcy5nZXQodHJhbnNjcmlwdElkKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2NyaXB0LnN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIiB8fCB0cmFuc2NyaXB0LnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb2xsaW5nVGltZW91dCA+IDAgJiZcbiAgICAgICAgICAgICAgICBEYXRlLm5vdygpIC0gc3RhcnRUaW1lID4gcG9sbGluZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2xsaW5nIHRpbWVvdXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBwb2xsaW5nSW50ZXJ2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zY3JpcHQuXG4gICAgICovXG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihgL3YyL3RyYW5zY3JpcHQvJHtpZH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcGFnZSBvZiB0cmFuc2NyaXB0IGxpc3RpbmdzLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBmaWx0ZXIgdGhlIHRyYW5zY3JpcHQgbGlzdCBieSwgb3IgdGhlIFVSTCB0byByZXRyaWV2ZSB0aGUgdHJhbnNjcmlwdCBsaXN0IGZyb20uXG4gICAgICovXG4gICAgYXN5bmMgbGlzdChwYXJhbXMpIHtcbiAgICAgICAgbGV0IHVybCA9IFwiL3YyL3RyYW5zY3JpcHRcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHVybCA9IHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHVybCA9IGAke3VybH0/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKE9iamVjdC5rZXlzKHBhcmFtcykubWFwKChrZXkpID0+IFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleV0/LnRvU3RyaW5nKCkgfHwgXCJcIixcbiAgICAgICAgICAgIF0pKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoSnNvbih1cmwpO1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY3JpcHRMaXN0SXRlbSBvZiBkYXRhLnRyYW5zY3JpcHRzKSB7XG4gICAgICAgICAgICB0cmFuc2NyaXB0TGlzdEl0ZW0uY3JlYXRlZCA9IG5ldyBEYXRlKHRyYW5zY3JpcHRMaXN0SXRlbS5jcmVhdGVkKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2NyaXB0TGlzdEl0ZW0uY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNjcmlwdExpc3RJdGVtLmNvbXBsZXRlZCA9IG5ldyBEYXRlKHRyYW5zY3JpcHRMaXN0SXRlbS5jb21wbGV0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB0cmFuc2NyaXB0XG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zY3JpcHQuXG4gICAgICovXG4gICAgZGVsZXRlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihgL3YyL3RyYW5zY3JpcHQvJHtpZH1gLCB7IG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRocm91Z2ggdGhlIHRyYW5zY3JpcHQgZm9yIGEgc3BlY2lmaWMgc2V0IG9mIGtleXdvcmRzLlxuICAgICAqIFlvdSBjYW4gc2VhcmNoIGZvciBpbmRpdmlkdWFsIHdvcmRzLCBudW1iZXJzLCBvciBwaHJhc2VzIGNvbnRhaW5pbmcgdXAgdG8gZml2ZSB3b3JkcyBvciBudW1iZXJzLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSB3b3JkcyAtIEtleXdvcmRzIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNlbnRlbmNlcy5cbiAgICAgKi9cbiAgICB3b3JkU2VhcmNoKGlkLCB3b3Jkcykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgd29yZHM6IHdvcmRzLmpvaW4oXCIsXCIpIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC92Mi90cmFuc2NyaXB0LyR7aWR9L3dvcmQtc2VhcmNoPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBzZW50ZW5jZXMgb2YgYSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzZW50ZW5jZXMuXG4gICAgICovXG4gICAgc2VudGVuY2VzKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihgL3YyL3RyYW5zY3JpcHQvJHtpZH0vc2VudGVuY2VzYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCBwYXJhZ3JhcGhzIG9mIGEgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgdHJhbnNjcmlwdC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcGFyYWdyYXBocy5cbiAgICAgKi9cbiAgICBwYXJhZ3JhcGhzKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoSnNvbihgL3YyL3RyYW5zY3JpcHQvJHtpZH0vcGFyYWdyYXBoc2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBzdWJ0aXRsZXMgb2YgYSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSB0cmFuc2NyaXB0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBzdWJ0aXRsZXMuXG4gICAgICogQHBhcmFtIGNoYXJzX3Blcl9jYXB0aW9uIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGVyIGNhcHRpb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN1YnRpdGxlcyB0ZXh0LlxuICAgICAqL1xuICAgIGFzeW5jIHN1YnRpdGxlcyhpZCwgZm9ybWF0ID0gXCJzcnRcIiwgY2hhcnNfcGVyX2NhcHRpb24pIHtcbiAgICAgICAgbGV0IHVybCA9IGAvdjIvdHJhbnNjcmlwdC8ke2lkfS8ke2Zvcm1hdH1gO1xuICAgICAgICBpZiAoY2hhcnNfcGVyX2NhcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoXCJjaGFyc19wZXJfY2FwdGlvblwiLCBjaGFyc19wZXJfY2FwdGlvbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHVybCArPSBgPyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHJlZGFjdGVkIGF1ZGlvIFVSTCBvZiBhIHRyYW5zY3JpcHQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHRyYW5zY3JpcHQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRldGFpbHMgb2YgdGhlIHJlZGFjdGVkIGF1ZGlvLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgcmVkYWN0ZWRBdWRpb2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICByZWRhY3Rpb25zKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZGFjdGVkQXVkaW8oaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcmVkYWN0ZWQgYXVkaW8gVVJMIG9mIGEgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgdHJhbnNjcmlwdC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGV0YWlscyBvZiB0aGUgcmVkYWN0ZWQgYXVkaW8uXG4gICAgICovXG4gICAgcmVkYWN0ZWRBdWRpbyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEpzb24oYC92Mi90cmFuc2NyaXB0LyR7aWR9L3JlZGFjdGVkLWF1ZGlvYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSByZWRhY3RlZCBhdWRpbyBmaWxlIG9mIGEgdHJhbnNjcmlwdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgdHJhbnNjcmlwdC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmV0Y2ggSFRUUCByZXNwb25zZSBvZiB0aGUgcmVkYWN0ZWQgYXVkaW8gZmlsZS5cbiAgICAgKi9cbiAgICBhc3luYyByZWRhY3RlZEF1ZGlvRmlsZShpZCkge1xuICAgICAgICBjb25zdCB7IHJlZGFjdGVkX2F1ZGlvX3VybCwgc3RhdHVzIH0gPSBhd2FpdCB0aGlzLnJlZGFjdGVkQXVkaW8oaWQpO1xuICAgICAgICBpZiAoc3RhdHVzICE9PSBcInJlZGFjdGVkX2F1ZGlvX3JlYWR5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVkYWN0ZWQgYXVkaW8gc3RhdHVzIGlzICR7c3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVkYWN0ZWRfYXVkaW9fdXJsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggcmVkYWN0ZWQgYXVkaW86ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJyYXlCdWZmZXI6IHJlc3BvbnNlLmFycmF5QnVmZmVyLmJpbmQocmVzcG9uc2UpLFxuICAgICAgICAgICAgYmxvYjogcmVzcG9uc2UuYmxvYi5iaW5kKHJlc3BvbnNlKSxcbiAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICBib2R5VXNlZDogcmVzcG9uc2UuYm9keVVzZWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jb25zdCByZWFkRmlsZSA9IGFzeW5jIChwYXRoKSA9PiBSZWFkYWJsZS50b1dlYihjcmVhdGVSZWFkU3RyZWFtKHBhdGgpKTtcblxuY2xhc3MgRmlsZVNlcnZpY2UgZXh0ZW5kcyBCYXNlU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGEgbG9jYWwgZmlsZSB0byBBc3NlbWJseUFJLlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBsb2NhbCBmaWxlIHBhdGggdG8gdXBsb2FkLCBvciBhIHN0cmVhbSBvciBidWZmZXIgb2YgdGhlIGZpbGUgdG8gdXBsb2FkLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB1cGxvYWRlZCBmaWxlIFVSTC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWQoaW5wdXQpIHtcbiAgICAgICAgbGV0IGZpbGVEYXRhO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICAgICAgZmlsZURhdGEgPSBkYXRhVXJsVG9CbG9iKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGVEYXRhID0gYXdhaXQgcmVhZEZpbGUoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbGVEYXRhID0gaW5wdXQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoSnNvbihcIi92Mi91cGxvYWRcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IGZpbGVEYXRhLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVwbGV4OiBcImhhbGZcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhLnVwbG9hZF91cmw7XG4gICAgfVxufVxuZnVuY3Rpb24gZGF0YVVybFRvQmxvYihkYXRhVXJsKSB7XG4gICAgY29uc3QgYXJyID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gICAgY29uc3QgbWltZSA9IGFyclswXS5tYXRjaCgvOiguKj8pOy8pWzFdO1xuICAgIGNvbnN0IGJzdHIgPSBhdG9iKGFyclsxXSk7XG4gICAgbGV0IG4gPSBic3RyLmxlbmd0aDtcbiAgICBjb25zdCB1OGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgdThhcnJbbl0gPSBic3RyLmNoYXJDb2RlQXQobik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQmxvYihbdThhcnJdLCB7IHR5cGU6IG1pbWUgfSk7XG59XG5cbmNvbnN0IGRlZmF1bHRTdHJlYW1pbmdVcmwkMSA9IFwid3NzOi8vc3RyZWFtaW5nLmFzc2VtYmx5YWkuY29tL3YzL3dzXCI7XG5jb25zdCB0ZXJtaW5hdGVTZXNzaW9uTWVzc2FnZSA9IGB7XCJ0eXBlXCI6XCJUZXJtaW5hdGVcIn1gO1xuY2xhc3MgU3RyZWFtaW5nVHJhbnNjcmliZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHdlYnNvY2tldEJhc2VVcmw6IHBhcmFtcy53ZWJzb2NrZXRCYXNlVXJsIHx8IGRlZmF1bHRTdHJlYW1pbmdVcmwkMSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwidG9rZW5cIiBpbiBwYXJhbXMgJiYgcGFyYW1zLnRva2VuKVxuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHBhcmFtcy50b2tlbjtcbiAgICAgICAgaWYgKFwiYXBpS2V5XCIgaW4gcGFyYW1zICYmIHBhcmFtcy5hcGlLZXkpXG4gICAgICAgICAgICB0aGlzLmFwaUtleSA9IHBhcmFtcy5hcGlLZXk7XG4gICAgICAgIGlmICghKHRoaXMudG9rZW4gfHwgdGhpcy5hcGlLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUEkga2V5IG9yIHRlbXBvcmFyeSB0b2tlbiBpcyByZXF1aXJlZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdGlvblVybCgpIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnBhcmFtcy53ZWJzb2NrZXRCYXNlVXJsID8/IFwiXCIpO1xuICAgICAgICBpZiAodXJsLnByb3RvY29sICE9PSBcIndzczpcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm90b2NvbCwgbXVzdCBiZSB3c3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAodGhpcy50b2tlbikge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnNldChcInRva2VuXCIsIHRoaXMudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJzYW1wbGVfcmF0ZVwiLCB0aGlzLnBhcmFtcy5zYW1wbGVSYXRlLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMuZW5kT2ZUdXJuQ29uZmlkZW5jZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnNldChcImVuZF9vZl90dXJuX2NvbmZpZGVuY2VfdGhyZXNob2xkXCIsIHRoaXMucGFyYW1zLmVuZE9mVHVybkNvbmZpZGVuY2VUaHJlc2hvbGQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLm1pbkVuZE9mVHVyblNpbGVuY2VXaGVuQ29uZmlkZW50KSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwibWluX2VuZF9vZl90dXJuX3NpbGVuY2Vfd2hlbl9jb25maWRlbnRcIiwgdGhpcy5wYXJhbXMubWluRW5kT2ZUdXJuU2lsZW5jZVdoZW5Db25maWRlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLm1heFR1cm5TaWxlbmNlKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwibWF4X3R1cm5fc2lsZW5jZVwiLCB0aGlzLnBhcmFtcy5tYXhUdXJuU2lsZW5jZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJhbXMuZm9ybWF0VHVybnMpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJmb3JtYXRfdHVybnNcIiwgdGhpcy5wYXJhbXMuZm9ybWF0VHVybnMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmVuY29kaW5nKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwiZW5jb2RpbmdcIiwgdGhpcy5wYXJhbXMuZW5jb2RpbmcudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmtleXRlcm1zUHJvbXB0KSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwia2V5dGVybXNfcHJvbXB0XCIsIEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1zLmtleXRlcm1zUHJvbXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJhbXMua2V5dGVybXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltEZXByZWNhdGlvbiBXYXJuaW5nXSBga2V5dGVybXNgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBQbGVhc2UgdXNlIGBrZXl0ZXJtc1Byb21wdGAgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuc2V0KFwia2V5dGVybXNfcHJvbXB0XCIsIEpTT04uc3RyaW5naWZ5KHRoaXMucGFyYW1zLmtleXRlcm1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmZpbHRlclByb2Zhbml0eSkge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnNldChcImZpbHRlcl9wcm9mYW5pdHlcIiwgdGhpcy5wYXJhbXMuZmlsdGVyUHJvZmFuaXR5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHVybC5zZWFyY2ggPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbm5lY3Rpb25VcmwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBmYWN0b3J5KHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gZmFjdG9yeSh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IHRoaXMuYXBpS2V5IH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9ICh7IGNvZGUsIHJlYXNvbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgaW4gU3RyZWFtaW5nRXJyb3JNZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gU3RyZWFtaW5nRXJyb3JNZXNzYWdlc1tjb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5jbG9zZT8uKGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZXJyb3I/LihldmVudC5lcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5lcnJvcj8uKG5ldyBFcnJvcihldmVudC5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZXJyb3I/LihuZXcgU3RyZWFtaW5nRXJyb3IobWVzc2FnZS5lcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCZWdpblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMub3Blbj8uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlR1cm5cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMudHVybj8uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRlcm1pbmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvblRlcm1pbmF0ZWRSZXNvbHZlPy4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZTogKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQXVkaW8oY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRBdWRpbyhhdWRpbykge1xuICAgICAgICB0aGlzLnNlbmQoYXVkaW8pO1xuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldCB8fCB0aGlzLnNvY2tldC5yZWFkeVN0YXRlICE9PSB0aGlzLnNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb2NrZXQgaXMgbm90IG9wZW4gZm9yIGNvbW11bmljYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhKTtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2Uod2FpdEZvclNlc3Npb25UZXJtaW5hdGlvbiA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gdGhpcy5zb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICAgIGlmICh3YWl0Rm9yU2Vzc2lvblRlcm1pbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25UZXJtaW5hdGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25UZXJtaW5hdGVkUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKHRlcm1pbmF0ZVNlc3Npb25NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2Vzc2lvblRlcm1pbmF0ZWRQcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZCh0ZXJtaW5hdGVTZXNzaW9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0Py5yZW1vdmVBbGxMaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMuc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtaW5nVHJhbnNjcmliZXJGYWN0b3J5IGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihwYXJhbXMpO1xuICAgICAgICB0aGlzLmJhc2VTZXJ2aWNlUGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICB0cmFuc2NyaWJlcihwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZVBhcmFtcyA9IHsgLi4ucGFyYW1zIH07XG4gICAgICAgIGlmICghc2VydmljZVBhcmFtcy50b2tlbiAmJiAhc2VydmljZVBhcmFtcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHNlcnZpY2VQYXJhbXMuYXBpS2V5ID0gdGhpcy5iYXNlU2VydmljZVBhcmFtcy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1pbmdUcmFuc2NyaWJlcihzZXJ2aWNlUGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlVGVtcG9yYXJ5VG9rZW4ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgLy8gQWRkIGVhY2ggcGFyYW0gdG8gdGhlIHNlYXJjaCBwYXJhbXNcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgdXJsID0gcXVlcnlTdHJpbmcgPyBgL3YzL3Rva2VuPyR7cXVlcnlTdHJpbmd9YCA6IFwiL3YzL3Rva2VuXCI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZldGNoSnNvbih1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhLnRva2VuO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdEJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLmFzc2VtYmx5YWkuY29tXCI7XG5jb25zdCBkZWZhdWx0U3RyZWFtaW5nVXJsID0gXCJodHRwczovL3N0cmVhbWluZy5hc3NlbWJseWFpLmNvbVwiO1xuY2xhc3MgQXNzZW1ibHlBSSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEFzc2VtYmx5QUkgY2xpZW50LlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHNlcnZpY2UsIGluY2x1ZGluZyB0aGUgQVBJIGtleSBhbmQgYmFzZSBVUkwsIGlmIGFueS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLmJhc2VVcmwgPSBwYXJhbXMuYmFzZVVybCB8fCBkZWZhdWx0QmFzZVVybDtcbiAgICAgICAgaWYgKHBhcmFtcy5iYXNlVXJsICYmIHBhcmFtcy5iYXNlVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgcGFyYW1zLmJhc2VVcmwgPSBwYXJhbXMuYmFzZVVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWxlcyA9IG5ldyBGaWxlU2VydmljZShwYXJhbXMpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpcHRzID0gbmV3IFRyYW5zY3JpcHRTZXJ2aWNlKHBhcmFtcywgdGhpcy5maWxlcyk7XG4gICAgICAgIHRoaXMubGVtdXIgPSBuZXcgTGVtdXJTZXJ2aWNlKHBhcmFtcyk7XG4gICAgICAgIHRoaXMucmVhbHRpbWUgPSBuZXcgUmVhbHRpbWVUcmFuc2NyaWJlckZhY3RvcnkocGFyYW1zKTtcbiAgICAgICAgdGhpcy5zdHJlYW1pbmcgPSBuZXcgU3RyZWFtaW5nVHJhbnNjcmliZXJGYWN0b3J5KHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIGJhc2VVcmw6IHBhcmFtcy5zdHJlYW1pbmdCYXNlVXJsIHx8IGRlZmF1bHRTdHJlYW1pbmdVcmwsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQXNzZW1ibHlBSSwgRmlsZVNlcnZpY2UsIExlbXVyU2VydmljZSwgUmVhbHRpbWVTZXJ2aWNlLCBSZWFsdGltZVNlcnZpY2VGYWN0b3J5LCBSZWFsdGltZVRyYW5zY3JpYmVyLCBSZWFsdGltZVRyYW5zY3JpYmVyRmFjdG9yeSwgU3RyZWFtaW5nVHJhbnNjcmliZXIsIFRyYW5zY3JpcHRTZXJ2aWNlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/assemblyai/dist/node.mjs\n");

/***/ })

};
;